"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const L = require("leaflet");
const luxon_1 = require("luxon");
require("./style.css");
const CSS_ACTIVE_SLOT_CLASS = 'leaflet-timeline-control__slot--active';
const CSS_BUTTON_CLASS = 'leaflet-timeline-control__button';
const CSS_CONTROL_CLASS = 'leaflet-timeline-control';
const CSS_SLOT_CLASS = 'leaflet-timeline-control__slot';
const CSS_TIMELINE_CLASS = 'leaflet-timeline-control__timeline';
class TimelineControl extends L.Control {
    constructor(options) {
        super(options);
        this.steps = this.createSteps();
        this.currentStep = this.steps[0];
    }
    onAdd(map) {
        this.map = map;
        const { autoplay } = this.options;
        if (autoplay) {
            this.createTimer();
        }
        this.container = this.renderDefault(map);
        this.button = this.renderButton();
        this.renderSlots();
        return this.container;
    }
    onRemove() {
        this.destroyTimer();
    }
    renderDefault(map) {
        return L.DomUtil.create('div', CSS_CONTROL_CLASS, map.getContainer());
    }
    renderButton() {
        const { button } = this.options;
        if (!button) {
            return;
        }
        const { pausedText, playingText, render } = button;
        const buttonElement = render ? render() : L.DomUtil.create('button', CSS_BUTTON_CLASS);
        this.container.appendChild(buttonElement);
        buttonElement.innerHTML = this.timer ? playingText : pausedText;
        buttonElement.addEventListener('click', () => {
            this.timer ? this.destroyTimer() : this.createTimer();
            buttonElement.innerHTML = this.timer ? playingText : pausedText;
        });
        return buttonElement;
    }
    handleSlotClick(slot, step) {
        const { onNextStep } = this.options;
        const slots = document.querySelectorAll('[data-date]');
        slots.forEach(item => item.classList.remove(CSS_ACTIVE_SLOT_CLASS));
        slot.classList.add(CSS_ACTIVE_SLOT_CLASS);
        this.currentStep = step;
        onNextStep(this.currentStep.toJSDate());
        this.renderSlots();
        this.destroyTimer();
    }
    renderSlots() {
        const { dateFormat } = this.options.timeline;
        const timeline = this.container.querySelector(`.${CSS_TIMELINE_CLASS}`) || L.DomUtil.create('div', CSS_TIMELINE_CLASS);
        this.container.appendChild(timeline);
        timeline.innerHTML = '';
        this.steps.forEach((step, i) => {
            const slot = this.renderSlot(step);
            timeline.appendChild(slot);
            slot.dataset.date = `${i}`;
            slot.innerHTML = step.toFormat(dateFormat);
        });
    }
    renderSlot(step) {
        const { renderActiveSlot, renderSlot } = this.options.timeline;
        let slot;
        if (step === this.currentStep) {
            const fn = renderActiveSlot || renderSlot;
            slot = fn ? fn() : L.DomUtil.create('div', `${CSS_SLOT_CLASS} ${CSS_ACTIVE_SLOT_CLASS}`);
        }
        else {
            slot = renderSlot ? renderSlot() : L.DomUtil.create('div', CSS_SLOT_CLASS);
        }
        slot.addEventListener('click', () => this.handleSlotClick(slot, step));
        return slot;
    }
    createTimer() {
        const { interval, onNextStep } = this.options;
        this.timer = setInterval(() => {
            const currentIndex = this.steps.findIndex(step => step === this.currentStep);
            const nextIndex = currentIndex < this.steps.length - 1 ? currentIndex + 1 : 0;
            this.currentStep = this.steps[nextIndex];
            this.renderSlots();
            onNextStep(this.currentStep.toJSDate());
        }, interval);
    }
    destroyTimer() {
        clearTimeout(this.timer);
        this.timer = null;
        if (this.button) {
            const { pausedText } = this.options.button;
            this.button.innerHTML = pausedText;
        }
    }
    createSteps() {
        const { range } = this.options.timeline;
        if (range.length > 2) {
            return range.map(date => luxon_1.DateTime.fromJSDate(date));
        }
        const { step } = this.options.timeline;
        const [start, end] = range;
        const interval = luxon_1.Interval.fromDateTimes(start, end);
        const equalIntervals = interval.splitBy(luxon_1.Duration.fromObject(step));
        const steps = equalIntervals
            .reduce((accum, value) => {
            accum.add(value.start);
            accum.add(value.end);
            return accum;
        }, new Set());
        return Array.from(steps);
    }
}
L.Control.Timeline = TimelineControl;
L.control.timeline = (opts) => new L.Control.Timeline(opts);
exports.default = L.control.timeline;
//# sourceMappingURL=index.js.map